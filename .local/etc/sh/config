#!/bin/sh
# Configuration for interactive shells.
# Expects to be sourced after profile.
# Written by ayekat on a warm summer day in 2013.

# Helper:
safeAlias(){
	local aliasTarget="$(printf '%s' "${1#*=}")"
	local aliasTargetBinary="${aliasTarget%% *}"
	[ -z "$aliasTargetBinary" ] && \alias && return # Query installed aliases.
	if [ -z "$(command -v "$aliasTargetBinary")" ]; then
		echo "Cannot resolve alias target $aliasTargetBinary" >&2
		return
	fi
	# It's fine, invoke real alias function
	\alias "$1"
}
# Override alias to have a safer alias
alias alias='safeAlias'

# }}}
# ------------------------------------------------------------------------------
# ALIASES {{{

# quite handy!
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."

alias cp='cp -i'
alias df='df -h'
alias fi.in='find . -iname'
alias fi.n='find . -name'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias l='ls -vCF'
alias ll='ls -valFh'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rlf='readlink -f'
alias rm='rm --one-file-system'
alias todo='grep -n -R "TODO\|FIXME\|XXX" .'
alias view="${EDITOR:=vim} -R"
alias wtf='dmesg | tail -n 20'

alias info='info --vi-keys' 2> /dev/null

alias xc='xclip -selection clipboard' 2> /dev/null

alias mixer="alsamixer"  2> /dev/null
alias mixer="pulsemixer" 2> /dev/null
alias mixer="pamix"      2> /dev/null

alias pacman='pacman --color always' 2> /dev/null

# Server only aliases (mostly additional security):
if [ -n "$SSH_CONNECTION" ]; then
	alias rm='rm -i'
fi

# }}}
# ------------------------------------------------------------------------------
# LOOK & FEEL {{{

# Set colours for gcc:
export GCC_COLORS='error=01;31:warning=33:note=36:caret=01;32:locus=37:quote=32'

# }}}
# ------------------------------------------------------------------------------
# PROMPT {{{

# Prompt colours:
pc_vcs_huge="$(printf "\033[1;30m")"
pc_vcs_clean="$(printf "\033[32m")"
pc_vcs_ahead="$(printf "\033[36m")"
pc_vcs_dvrgd="$(printf "\033[1;36m")"
pc_vcs_ready="$(printf "\033[33m")"
pc_vcs_dirty="$(printf "\033[31m")"
pc_vcs_merge="$(printf "\033[1;31m")"
pc_host=$(printf "\033[35m")
pc_pwd=$(printf "\033[34m")
pc_prompt=$(printf "\033[1;31m")
pc_jobs=$(printf "\033[30;47m")

# VCS
# vcs_state and vcs_branch are set by calling vcs_update() with the path to the
# git repository.
vcs_state=''
vcs_branch=''
vcs_update()
{
	# Don't calculate git repo infos on slow machines or huge repositories:
	case "$(hostname)" in
		ds-wrk3)
			vcs_branch='git'
			vcs_state='slow'
			return ;;
	esac
	case "$1" in
		"$HOME"/dev/linux)
			vcs_branch='git'
			vcs_state='huge'
			return ;;
	esac

	git_head="$(git -C "$1" status --porcelain -b 2>/dev/null | head -n 1)"
	vcs_state=''
	vcs_branch="$(echo "$git_head" | sed -e 's/^## \([^.]\+\).*/\1/g')"
	if [ -n "$vcs_branch" ]; then
		git_status="$(git -C "$1" status --porcelain 2>/dev/null | cut -c 1-2)"
		vcs_state=clean
		echo "$git_head"|grep ' \[ahead [0-9]\+\]$'>/dev/null&&vcs_state=ahead
		echo "$git_head"|grep ' \[ahead [0-9]\+, behind [0-9]\+\]$'>/dev/null \
			&& vcs_state=dvrgd
		echo "$git_status" | grep '^[MADR]' >/dev/null && vcs_state=ready
		echo "$git_status" | grep '^.[M?DR]' >/dev/null && vcs_state=dirty
		echo "$git_status" | grep '^UU' >/dev/null && vcs_state=merge
	fi
	unset git_head
}

# }}}
# ------------------------------------------------------------------------------
