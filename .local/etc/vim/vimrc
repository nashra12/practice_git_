" Vim main configuration file
"
"     2010-2017 - «ayekat»
" (C) 2016-2017 - Roosembert Palacios <roosembert.palacios@epfl.ch>
" Released under CC BY-NC-SA License: https://creativecommons.org/licenses/
" TODO: Consider changing licence to Apache2

set nocompatible
set nomodeline
"
" Make sure the damn paths exists:
function! MakeSureTheDamnPathExists(path)
	if !isdirectory(a:path)
		call mkdir(a:path, 'p', 0700)
	endif
endfunction

" ------------------------------------------------------------------------------
" PATHS {{{
" We like to respect the XDG base directory specifications

" Scripts' location:
if empty($XDG_DATA_HOME)
  let $XDG_DATA_HOME = $HOME."/run"
endif
call MakeSureTheDamnPathExists($XDG_DATA_HOME)
if empty($XDG_RUNTIME_DIR)
  let $XDG_RUNTIME_DIR = $HOME."/run"
endif
call MakeSureTheDamnPathExists($XDG_RUNTIME_DIR)
if empty($XDG_CONFIG_HOME )
  let $XDG_CONFIG_HOME = $HOME."/run"
endif
call MakeSureTheDamnPathExists($XDG_CONFIG_HOME)

set runtimepath=$XDG_DATA_HOME/vim,$XDG_DATA_HOME/vim/after,$VIM,$VIMRUNTIME

" Backup files:
set backupdir=$XDG_RUNTIME_DIR/vim/backup

" Swap files:
set directory=$XDG_DATA_HOME/vim/swap

" Command and undo history:
set viminfo+=n$XDG_DATA_HOME/vim/viminfo
set undofile
au BufWritePre /tmp/*,/dev/shm/*,/run/shm/* setl noundofile
set undodir=$XDG_DATA_HOME/vim/undo

call MakeSureTheDamnPathExists($XDG_RUNTIME_DIR.'/vim')
call MakeSureTheDamnPathExists($XDG_DATA_HOME.'/vim')
call MakeSureTheDamnPathExists(&directory)
call MakeSureTheDamnPathExists(&undodir)
call MakeSureTheDamnPathExists(&backupdir)

" }}}
" ------------------------------------------------------------------------------
" BUNDLES {{{

let g:bundledir=$XDG_DATA_HOME.'/vim/neobundle'
let g:bundleinit=0
"
" Initialise and bootstrap NeoBundle (here goes my thanks to flor):
if has('vim_starting')
	if !isdirectory(g:bundledir)
		let g:bundleinit=1
		call mkdir(g:bundledir, 'p', 0700)
		!git clone 'https://github.com/Shougo/neobundle.vim' $XDG_DATA_HOME/vim/neobundle/neobundle.vim
	endif
	set runtimepath+=$XDG_DATA_HOME/vim/neobundle/neobundle.vim
endif

" List of bundles I use (including NeoBundle itself): "
call neobundle#begin(expand('$XDG_DATA_HOME/vim/neobundle/'))
NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'scrooloose/nerdtree'
NeoBundle 'Lokaltog/vim-easymotion'
NeoBundle 'vim-scripts/Align'
NeoBundle 'vim-scripts/csv.vim'
NeoBundle 'sjl/gundo.vim'
NeoBundle 'shawncplus/skittles_berry'
NeoBundle 'mileszs/ack.vim'
NeoBundle 'benatkin/vim-move-between-tabs'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-tbone'
NeoBundle 'Shougo/vinarise.vim'        " Hex editor
NeoBundle 'ap/vim-css-color'
NeoBundle 'chrisbra/vim-diff-enhanced'
NeoBundle 'haya14busa/incsearch.vim'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'jceb/vim-orgmode'
NeoBundle 'tpope/vim-speeddating'
NeoBundle 'Twinside/vim-hoogle'
"NeoBundle 'vim-scripts/diffchar.vim'

NeoBundle 'yuratomo/w3m.vim'

NeoBundle 'scrooloose/syntastic'

NeoBundle 'tpope/vim-surround'
NeoBundle 'vim-scripts/glsl.vim'
NeoBundle 'Matt-Stevens/vim-systemd-syntax'
NeoBundle 'vim-scripts/bbcode'
NeoBundle 'rust-lang/rust.vim'
NeoBundle 'rosstimson/scala-vim-support'
NeoBundle 'EdJoJob/llvmir-vim'

"NeoBundle 'honza/dockerfile.vim'
"NeoBundle 'nfnty/vim-nftables'

" Initial run requires NeoBundleInstall, as a simple 'Check' won't suffice:
if g:bundleinit
	NeoBundleInstall
else
	NeoBundleCheck
endif
call neobundle#end()

" Use ag instead of ack if possible
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif

" }}}
" ------------------------------------------------------------------------------
" SYNTAX {{{

" Without any syntax highlighting, programming is a pain:
syntax on

" Fix unrecognised file types:
au BufRead,BufNewFile *.md setl filetype=markdown
au BufRead,BufNewFile *.tex setl filetype=tex
au BufRead,BufNewFile *.frag,*.vert,*.geom,*.glsl setl filetype=glsl
au BufRead,BufNewFile dunstrc,redshift.conf setl filetype=cfg
au BufRead,BufNewFile *.target setl filetype=systemd

" Assembly:
let asmsyntax='nasm'

" C:
let c_no_curly_error=1 " Allow {} inside [] and () (non-ANSI)
let c_space_errors=1   " Highlight trailing spaces and spaces before tabs
let c_syntax_for_h=1   " Treat .h as C header files (instead of C++)

" Shell:
let g:is_posix=1       " /bin/sh is POSIX shell, not deprecated Bourne shell

" }}}
" ------------------------------------------------------------------------------
" WHITESPACE {{{

" Fix trailing whitespaces when saving file with `:W`:
function! StripTrailingWhitespaces()
	let _s=@/
	let l=line('.')
	let c=col('.')
	%s/\s\+$//eg
	call cursor(l,c)
	let @/=_s
endfunction
command! W :call StripTrailingWhitespaces() | :write

" Fold C function implemenations:
function! CFold()
	let prevline = getline(v:lnum-1)
	let nextline = getline(v:lnum+1)
	if match(nextline, '^{') >= 0
		return 1
	elseif match(prevline, '^}') >= 0
		return 0
	else
		return "="
	endif
endfunction
au FileType c setl foldmethod=expr
au FileType c setl foldexpr=CFold()

" Auto-indent, and reuse the same combination of spaces/tabs:
filetype plugin indent on
set autoindent
set copyindent

" Indentation (tabs, spaces):
set expandtab tabstop=2 shiftwidth=2
au FileType c setl tabstop=4 shiftwidth=4

" Visually wrap lines and break words:
set wrap
au FileType html,java,markdown,scala setl nowrap
set linebreak      " wrap at words (does not work with list)

" Physically wrap lines:
au FileType markdown,tex,rst setl textwidth=120
au FileType gitcommit,mail setl textwidth=86
" }}}
" ------------------------------------------------------------------------------
" LOOK {{{

" Colors, after syntax!, `syntax enable` doesn't seems to work...
if exists($XDG_CONFIG_HOME."/vim/colors.vim")
  source $XDG_CONFIG_HOME/vim/colors.vim
elseif exists($HOME."/colors.vim")
  source $HOME/colors.vim
endif

" statusline!
if exists($XDG_CONFIG_HOME."/vim/statusline.vim")
  source $XDG_CONFIG_HOME/vim/statusline.vim
elseif exists($HOME."/statusline.vim")
  source $HOME/statusline.vim
endif

" Display and format line numbers:
set number
set relativenumber
set numberwidth=5

" Enable UTF-8 (I wanna see Umlauts!):
set encoding=utf8

" Display a bar after a reasonable number of columns:
set colorcolumn=81,121
au FileType mail,gitcommit setl colorcolumn=87
au FileType java,cs setl colorcolumn=121
au FileType asm setl colorcolumn=41,81

" I wanna see tabs and trailing whitespaces:
set list
set listchars=tab:→\ ,eol:\ ,trail:·

" Window separator:
if $TERM == 'linux'
	set fillchars=vert:.
else
	set fillchars=vert:│
endif

" Fold fill characters:
set fillchars+="fold: "

" Autofold (except in git commit message):
set foldmethod=marker
au FileType gitcommit setl foldmethod=manual

" }}}
" ------------------------------------------------------------------------------
" KEY BINDINGS, BEHAVIOUR {{{

" Fix Backspace key to work current edit:
set backspace=indent,eol,start

" Leader key:
let mapleader=';'

" Keep 3 lines 'padding' above/below the cursor:
set scrolloff=3

" Simple cursor moving on visual lines:
map k gk
map j gj

" Remove delay for leaving insert mode:
set timeoutlen=1000 ttimeoutlen=0

" Window manipulation: Resize window
nnoremap <leader>K <C-W>+
nnoremap <leader>J <C-W>-
nnoremap <leader>L <C-W>>
nnoremap <leader>H <C-W><

" Manipulate windows: Move between windows
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Open underlying file in splits:
nmap <C-w>w :rightbelow wincmd f<CR>
nmap <C-w>e :rightbelow vertical wincmd f<CR>

" Tabbed window handling:
map <leader>l :tabnext<CR>
map <leader>h :tabprevious<CR>
map <leader>t :tabnew<CR>
set tabpagemax=20

" Show 10 last commands in the window
set cmdwinheight=10

" Search for tags file recursively, up to root:
set tags=./tags;/

" Save a file as root (WARNING: breaks file undo history):
" command! Rw :execute ':silent w !sudo tee % > /dev/null' | :edit!
cmap w!! w !sudo tee % >/dev/null<CR>

" Undo-tree:
map <leader>u :GundoToggle<CR>

" NERDTree
nmap <leader>o :NERDTreeToggle<CR>

" Fugitive
nmap <leader>g :Gstatus<CR>

" Quickfix
nmap <leader>M :cclose<CR>
nmap <leader>m :copen<CR>
nmap <leader>N :cprevious<CR>
nmap <leader>n :cnext<CR>

" Incsearch
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)

" Execure the line under the cursor
vmap ! :!sh<CR>

" Enable Mouse Support
set mouse=a

" }}}
" ------------------------------------------------------------------------------
" COMMAND LINE FEEDBACK {{{

" Display commands when typing:
set showcmd

" Highlight search results and display them immediately as they are typed:
set hlsearch
set incsearch

" Ignore case when searching, except when explicitely using uppercase:
set ignorecase
set smartcase

" Word-breaking characters:
set iskeyword-=[.]

" Highlight matching parentheses:
set showmatch

" }}}
" ------------------------------------------------------------------------------
" LINE NUMBERS {{{
" Make line number design change as a function of mode.

if $TERM != 'linux'
	set cursorline

	hi N_linenr         ctermfg=244 ctermbg=236
	hi N_linenr_cursor  ctermfg=148 ctermbg=8
	hi N_cursorline                 ctermbg=none
	hi V_linenr         ctermfg=208 ctermbg=52
	hi V_linenr_cursor  ctermfg=52  ctermbg=208
	hi V_cursorline                 ctermbg=none
	hi I_linenr         ctermfg=45  ctermbg=23
	hi I_linenr_cursor  ctermfg=7   ctermbg=31
	hi I_cursorline                 ctermbg=235

	function! SetLineNr(mode)
		" TODO: check whether in (in)active window
		hi clear LineNr
		hi clear CursorLineNr
		hi clear CursorLine
		if a:mode == 'i'
			hi link LineNr       I_linenr
			hi link CursorLineNr I_linenr_cursor
			hi link CursorLine   I_cursorline
		elseif a:mode == 'v'
			hi link LineNr       V_linenr
			hi link CursorLineNr V_linenr_cursor
			hi link CursorLine   V_cursorline
		else
			hi link LineNr       N_linenr
			hi link CursorLineNr N_linenr_cursor
			hi link CursorLine   N_cursorline
		endif
	endfunction

	" insert mode:
	au! InsertLeave * call SetLineNr('n')
	au! InsertEnter * call SetLineNr('i')
	au BufEnter,WinEnter * call SetLineNr('n')

	" visual mode (ugly, since there is no VisualEnter/VisualLeave):
	noremap <silent> v :call SetLineNr('v')<CR>v
	noremap <silent> V :call SetLineNr('v')<CR>V
	noremap <silent> <C-v> :call SetLineNr('v')<CR><C-v>
	set updatetime=0
	au! CursorHold * call SetLineNr('n')
endif

" }}}
" ------------------------------------------------------------------------------
